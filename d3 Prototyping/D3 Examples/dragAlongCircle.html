<!DOCTYPE html>
<meta charset="utf-8">
<body>
<style>

    path {
        fill: none;
        stroke: #000;
        stroke-width: 3px;
    }

</style>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>
    var line = d3.svg.line().tension(0).interpolate("basis-closed");

    var cx = 80, cy = 40; //Position of the draggable point
    var radius = 100;
    //Caution: do not use 360, always use 0!
    var orientationAngle = Math.PI/2; //An angle for how to translate the loop (how is the loop aligned w.r.t the stationary point), opposite to the crossing angle
    var loopCx = cx + (radius/2)*Math.cos(orientationAngle);
    var loopCy = cy + (radius/2)*Math.sin(orientationAngle);
    var interpValue = 0;

    //Not sure which one of these are needed...
    var crossingAngle = (orientationAngle > Math.PI)?(orientationAngle-Math.PI):(orientationAngle+Math.PI); //The angle to pass in order to count revolutions
    var points = generatePoints(cx,cy); //Generate a set of points for drawing the curve
    var previousDragDirection = 1;
    var previousAngle = "start";
    var crossed = 0; //Flag to tell whether the dragging has passed the crossingAngle on the loop

    //Set up the main svg
    var svg = d3.select("body").append("svg")
            .attr("width", 960).attr("height", 500)
            .style("position","absolute").attr("x",50).attr("y",50)
            .append("g").attr("transform","translate(150,150)");

    //Draw the spline
    svg.append("path").attr("id","mainPath").attr("d", line(points));

    //Draw another circle which is the centre point of the circle
    svg.append("circle").attr("cx",loopCx).attr("cy",loopCy).attr("fill","steelblue")
            .attr("r",5).attr("id","centrePoint");

    //Draw the draggable circle
    svg.append("circle").attr("cx",cx).attr("cy",cy).attr("r",10).attr("fill","red").attr("id","draggableCircle");

    //Create the dragging function
    var dragging = d3.behavior.drag()
            .on("dragstart", function (d){
                previousAngle = "start";
                crossed = 0;
                return d;
            }).on("drag", function(){

                var mouseX = d3.event.x, mouseY = d3.event.y;

                //Find the angle of the mouse w.r.t the center of the loop, also set the interpolation value
                var mouseAngle = calculateMouseAngle(mouseX,mouseY);
                //Re-map the interpolation value to draw properly on the loop
                var loopInterp = convertMouseToLoop_interp(interpValue);
                //console.log(interpValue);

                //Re-draw the circle according to the new estimated point along the spline
                var path = d3.select("#mainPath").node();
                var total = path.getTotalLength();
                var currentLength = total*loopInterp;
                var newPoint = path.getPointAtLength(currentLength);
                d3.select("#draggableCircle").attr("cx",newPoint.x).attr("cy",newPoint.y);

                //Some how detect if one revolution has been reached
                /**if (previousAngle != "start" && previousAngle <1 && mouseAngle >0) {
                    console.log("crossed "+previousAngle*180/Math.PI+" "+mouseAngle*180/Math.PI);
                } */

                //Save some important information
                previousAngle = mouseAngle;
                /**previousDragDirection = draggingDirection;
                crossed = currentHalf;   */

            });

    //Set the dragging function of the draggable circle
    svg.select("#draggableCircle").call(dragging);

//TODO: Can still use old method of flipping of the angle sign to determine a view change
function calculateMouseAngle (mouseX,mouseY){
    var newAngle;
    var subtractOne = 0;
    if (orientationAngle<Math.PI/2 && orientationAngle>=0){ //Between 0 (inclusive) and 90
        //console.log("0 inc and 90");
        newAngle = Math.atan2(mouseY - loopCy, loopCx - mouseX) + orientationAngle; //0/360 deg
    }else if (orientationAngle < Math.PI*2 && orientationAngle >= Math.PI*3/2){ //Between 360/0 and 270 (inclusive)
        //console.log("0 and 270 inc");
        subtractOne = 1;
        newAngle = Math.atan2(loopCx - mouseX,mouseY - loopCy) - (orientationAngle - Math.PI*3/2);  //270 deg
    }else if (orientationAngle < Math.PI*3/2 && orientationAngle >=Math.PI){ //Between 270 and 180 (inclusive)
        //console.log("270 and 180 inc");
        newAngle =  Math.atan2(loopCy - mouseY, mouseX - loopCx) + (orientationAngle-Math.PI); //180 deg
    }else{
        //console.log("180 and 90 inc");
        subtractOne = 1;
        newAngle = Math.atan2(mouseX - loopCx, loopCy - mouseY) -(orientationAngle - Math.PI/2); // 90 deg
    }

    var positiveAngle = (newAngle < 0)?((Math.PI - newAngle*(-1))+Math.PI):newAngle;
    if (subtractOne ==1){
        interpValue = 1 - positiveAngle/(Math.PI*2);
    } else{
        interpValue =  positiveAngle/(Math.PI*2);
    }
    return  positiveAngle;
}
//Convert mouse angle into the loop's coordinate system such that the anchor can be drawn at the correct position along the loop
function convertMouseToLoop_angle (mouseAngle){

    if (mouseAngle<Math.PI/2 && mouseAngle>=0){
        return (Math.PI/2 - mouseAngle);
    }else if (mouseAngle < Math.PI*2 && mouseAngle >= Math.PI*3/2){
        return (Math.PI - (mouseAngle - Math.PI*3/2));
    }else{
        return (Math.PI + (Math.PI*3/2 - mouseAngle));
    }
}
//Convert mouse angle into the loop's coordinate system such that the anchor can be drawn at the correct position along the loop
function convertMouseToLoop_interp (mouseInterp){
    if (mouseInterp >=0 && mouseInterp <0.5){
        return mouseInterp+0.5;
    }else{
        return mouseInterp-0.5;
    }
}
//Finds the dragging direction w.r.t the center of the loop
function findDraggingDirection (mouseAngle){
    if (mouseAngle>previousAngle){
        return -1; //Counter-clockwise
    }else if (mouseAngle < previousAngle){
       return 1;  //Clockwise
    }else{
        return previousDragDirection;
    }
}
/**Generates a set of points which extend from cx,cy in arbitrary angular directions */
function generatePoints(cx,cy){
    var points = [];
    points.push([cx,cy]);
    var x,y;

    points.push([(cx + radius*Math.cos(orientationAngle+Math.PI/5)),(cy+ radius*Math.sin(orientationAngle+Math.PI/5))]);
    points.push([(cx + radius*Math.cos(orientationAngle)),(cy+ radius*Math.sin(orientationAngle))]);
    points.push([(cx + radius*Math.cos(orientationAngle-Math.PI/5)),(cy+ radius*Math.sin(orientationAngle-Math.PI/5))]);


    points.push([cx,cy]);
    return points;
}

</script>