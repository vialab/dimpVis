<!DOCTYPE html>
<meta charset="utf-8">
<body>
<style>

path {
  fill: none;
  stroke: #000;
  stroke-width: 3px;
}

</style>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

/** From the examples: http://bl.ocks.org/mbostock/5649592 and http://bl.ocks.org/mbostock/1705868
 *  this is an example of dragging a point along a spline curve */

var line = d3.svg.line().tension(0).interpolate("basis-closed");
//var line = d3.svg.line().interpolate("monotone");
    
var cx = 80, cy = 40; //Closing part of loop
var radius = 200;
var centreAngle = Math.PI; //An angle for how to orient the loop (how is the loop aligned w.r.t the stationary point)

var points = generatePoints(cx,cy); //Generate a set of points for drawing the curve
var previousSign = 1;
var previousAngle = "start";

//Set up the main svg
var svg = d3.select("body").append("svg")
    .datum(points)
    .attr("width", 960).attr("height", 500)
    .style("position","absolute").attr("x",50).attr("y",50)
    .append("g").attr("transform","translate(150,150)");

//Draw the individual points (mainly for debugging)
svg.selectAll(".points").data(points).enter()
        .append("circle").attr("class",".points")
        .attr("cx", function (d){return d[0]})
        .attr("cy", function (d){return d[1]})
        .attr("r",5);

//Draw the spline
svg.append("path").attr("id","mainPath").attr("d", line);

//Draw another circle which is the approximate centre point of the spline loop
svg.append("circle").attr("cx",(cx+ (radius/2)*Math.cos(centreAngle))).attr("cy",(cy + (radius/2)*Math.sin(centreAngle)))
        .attr("r",5).attr("fill","steelblue").attr("id","centrePoint");

//Draw the draggable circle
svg.append("circle").attr("cx",cx).attr("cy",cy).attr("r",10).attr("fill","red").attr("id","draggableCircle");

//Create the dragging function
var dragging = d3.behavior.drag()
        .on("dragstart", function (d){
            previousAngle = "start";
            return d;
        }).on("drag", function(){
            //Approach: Using the flipping of the angle sign (positive and negative) to know when the user has at least travelled 180 deg.
            var mouseX = d3.mouse(this)[0], mouseY = d3.mouse(this)[1];
            var centreX = cx + (radius/2)*Math.cos(centreAngle);
            var centreY =  cy + (radius/2)*Math.sin(centreAngle);

            //Draw the draggable circle
            var angle = Math.atan2(mouseX-centreX,mouseY-centreY);
            //console.log(angle*180/Math.PI);
            var sign = (angle>0)?1:-1;
            //Convert negative angle into positive
            var mouseAngle = (angle < 0)?((Math.PI - angle*(-1))+Math.PI):angle;
             console.log(mouseAngle*180/Math.PI);
            var draggingDirection = (mouseAngle>previousAngle)?-1:1;
            if (sign!=previousSign && previousAngle !="start"){ //Switching Directions
                var angle_deg = Math.abs(angle)*180/Math.PI;
                console.log(angle_deg);
                if (!(angle_deg > 0 && angle_deg < 20)){ //Ignore sign switches within 20 deg from the zero/360 mark
                    if (draggingDirection==1){
                        console.log("view increased, clockwise");
                    }else{
                        console.log("view decreased, counter-clockwise");
                    }
                }
            }
            // console.log(angle*180/Math.PI+" "+previousOrigAngle*180/Math.PI);
            //Save some important information
            previousAngle = mouseAngle;
            previousSign = sign;

            //Find the approximate percentage the mouse has travelled (angular) along a circle using the middle of the loop as the centre
            var distanceAlongCircle = mouseAngle/(Math.PI*2);
            /**var adjust = (1-distanceAlongCircle+0.15);
            if (adjust > 1){adjust = adjust - 1}*/

            //console.log(distanceAlongCircle+" "+adjust);
            var path = d3.select("#mainPath").node();
            var total = path.getTotalLength();
            //var currentLength = total*(1-distanceAlongCircle); //Better, but gets stuck at 100% because current length is > totalLength
            var currentLength = total*0.5;
            var newPoint = path.getPointAtLength(currentLength);


            //Original Approach: counting the revolutions by summing the difference in angles, but is inaccurate
            //when angle wraps around 360 deg...

            //Re-draw the circle according to the new estimated point along the spline
            d3.select("#draggableCircle").attr("cx",newPoint.x).attr("cy",newPoint.y);

        });

//Set the dragging function of the draggable circle
svg.select("#draggableCircle").call(dragging);

/**Generates a set of points which extend from cx,cy in arbitrary angular directions */
function generatePoints(cx,cy){
    var points = [];
    points.push([cx,cy]);
    var x,y;
    //Oriented on the right hand side
    /**points.push([(cx + radius*Math.cos(-Math.PI/6)),(cy+ radius*Math.sin(-Math.PI/6))]);
    points.push([(cx + radius*Math.cos(0)),(cy+ radius*Math.sin(0))]);
    points.push([(cx + radius*Math.cos(Math.PI/6)),(cy+ radius*Math.sin(Math.PI/6))]);*/
    
    //Oriented left hand side
    points.push([(cx + radius*Math.cos(5*Math.PI/6)),(cy+ radius*Math.sin(5*Math.PI/6))]);
    points.push([(cx + radius*Math.cos(Math.PI)),(cy+ radius*Math.sin(Math.PI))]);
    points.push([(cx + radius*Math.cos(-5*Math.PI/6)),(cy+ radius*Math.sin(-5*Math.PI/6))]);

    //Oriented lower right, at 30 deg
   /** var angle = centreAngle;
    for (var j = 0; j <= 2;j++){
        points.push([(cx + radius*Math.cos(angle*j)),(cy+ radius*Math.sin(angle*j))]);
    }*/
    points.push([cx,cy]);
    return points;
}

</script>