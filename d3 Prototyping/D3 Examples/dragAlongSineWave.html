<!DOCTYPE html>
<meta charset="utf-8">
<body>
<style>

path {
  fill: none;
  stroke: #000;
  stroke-width: 2px;
}

</style>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

/** This is an example of dragging a point along a sine wave */

var createLine = d3.svg.line()
    .interpolate("basis");

var bx = 80, by= 40; //Positioning the wave
var radius = 200;
var amplitude = 50;
var xSpacing = 20;
var startDirection = -1; //Starts with a trough
var endDirection = 1; //Ends with a peak
var currentDirection = startDirection;
var boundary = null;
var currentView = 0, nextView = 1;

var points = generatePoints(10,9); //Generate a set of points for drawing the curve
//var viewPoints = [];
//points.map(function (d){ if (d[1].toFixed(0)!=by) viewPoints.push(d[1])}); //Points indexed to the views

var horizontalLength = points[points.length-1][0] - bx; //how big the sinewave spans horizontally

//Set up the main svg
var svg = d3.select("body").append("svg")
    .datum(points)
    .attr("width", 960)
    .attr("height", 500);

//Draw the individual points (mainly for debugging)
svg.selectAll(".points").data(points).enter()
        .append("circle").attr("r",5)
        .attr("cx", function (d){return d[0]})
        .attr("cy", function (d){return d[1]})
        .attr("class",".points");

//Draw the spline
svg.append("path")
     .attr("id","mainPath")
     .attr("d", createLine);

//Draw the draggable circle
svg.append("circle").attr("cx",bx).attr("cy",by).attr("r",10)
        .attr("fill","red").attr("id","draggableCircle");

//Create the dragging function
var dragging = d3.behavior.drag()
        .on("drag", function(){
            var mouseY = d3.event.y, mouseX = d3.event.x;
           // var boundary = (currentDirection==1)?(by-amplitude):(amplitude+by);
            var pt1 = points[currentView];
            var pt2 = points[nextView];
            var bounds = checkBounds(pt1[1],pt2[1],mouseY);
            if (bounds == mouseY){
                var path = d3.select("#mainPath").node();
                var length = path.getTotalLength();
                var minDist = minDistancePoint(mouseX,mouseY,pt1[0],pt1[1],pt2[0],pt2[1]);
                var amountTravelled =  (mouseX - bx)/horizontalLength;
                var newPoint = path.getPointAtLength(length*amountTravelled);
                d3.select("#draggableCircle").attr("cx",newPoint.x).attr("cy",newPoint.y);
                return;
            }
            else if (bounds == boundary){
                console.log("at boundary");
            }else{
                console.log("at base");
            }
        });

//Set the dragging function of the draggable circle
svg.select("#draggableCircle").call(dragging);

/**Generates a set of points which extend from cx,cy in arbitrary angular directions
 * base: the horizontal axis of the wave
 * length: number of points (draw half a period between points) */
function generatePoints(base,length){
    var pathPoints = [];
    //Calculate the period
    var totalPts = length + (length-1);
    var angle = 0;
    for (var j=0;j<totalPts;j++){
        var theta = angle + (Math.PI/2)*j;
        var y = amplitude*Math.sin(theta)+by;
        var x = (xSpacing/2)*j + bx;
        pathPoints.push([x,y]);
    }
    return pathPoints;
}

function checkBounds (h1,h2,mouseY){
    //Resolve the boundaries
    var start,end;
    if (h1>h2){
        end = h1;
        start =h2;
    }else{
        start = h1;
        end = h2;
    }

    //Check if the mouse is between start and end values
    if (mouseY <= start) {
        return start;
    }else if (mouseY >=end) {
        return end;
    }
    //Find the amount travelled from current to next view (remember: h1 is current and h2 is next)
    /**var distanceTravelled = Math.abs(mouseY-h1);
    var totalDistance = Math.abs(h2 - h1);
    var distanceRatio = distanceTravelled/totalDistance;
    //Set the previous direction
    if (distanceRatio > this.interpValue){ //Moving forward
        if (this.previousDirection == -1){
            this.previousDirection = 1;
        }
    }else { //Going backward
        if (this.previousDirection == 1){
            this.previousDirection = -1;
        }
    }
    //Save the current interpolation value
    this.interpValue = distanceRatio;*/
    return mouseY;
}

function minDistancePoint (x,y,pt1_x,pt1_y,pt2_x,pt2_y){

    var distance = calculateDistance(pt1_x,pt1_y,pt2_x,pt2_y);
    //Two points of the line segment are the same
    if (distance == 0) return [pt1_x,pt1_y,0];

    var t = ((x - pt1_x) * (pt2_x - pt1_x) + (y - pt1_y) * (pt2_y - pt1_y)) / distance;
    if (t < 0) return [pt1_x,pt1_y,t]; //Point projection goes beyond pt1
    if (t > 1) return [pt2_x,pt2_y,t]; //Point projection goes beyond pt2

    //Otherwise, point projection lies on the line somewhere
    var minX = pt1_x + t*(pt2_x-pt1_x);
    var minY = pt1_y + t*(pt2_y-pt1_y);
    return [minX,minY,t];
}

function calculateDistance (x1,y1,x2,y2){
    var term1 = x1 - x2;
    var term2 = y1 - y2;
    return (term1*term1)+(term2*term2);
}

</script>