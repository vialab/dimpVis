<!DOCTYPE html>
<meta charset="utf-8">
<body>
<style>

path {
  fill: none;
  stroke: #c7c7c7;
  stroke-width: 2px;
  stroke-dasharray:3,3;
}
#draggableCircle {
    fill: #FFF;
    stroke: #c7c7c7;
    stroke-width: 2px;
}

</style>
<script src="../JS/d3.js"></script>
<script>

/** This is an example of dragging a point along a sine wave */

var createLine = d3.svg.line()
    .interpolate("monotone"); //Cubic interpolation, need more points to make it look smoother

var bx = 80, by= 40; //Positioning the wave
var radius = 200;
var amplitude = 30;
var xSpacing = 40;
var startDirection = -1; //Starts with a trough
var endDirection = 1; //Ends with a peak
var currentDirection = startDirection;

var allPoints = generatePoints(9); //Generate a set of points for drawing the curve
var points = allPoints[0]; //All points to make the dataset more fine grained (smoother curve)
var viewPoints = allPoints[1]; //Points indexed to the views

//Set up the main svg
var svg = d3.select("body").append("svg")
    .datum(points)
    .attr("width", 960)
    .attr("height", 500);

//Draw the individual points (debugging)
/**svg.selectAll(".points").data(points).enter()
        .append("circle").attr("r",3)
        .attr("cx", function (d){return d[0]})
        .attr("cy", function (d){return d[1]})
        .attr("class",".points");*/

//Draw some labels at each peak/trough
svg.selectAll(".labels").data(viewPoints).enter()
        .append("text").text(function (d,i) {return i;})        
        .attr("x", function (d){return d[0]})
        .attr("y", function (d){return d[1]})
        .attr("class","labels")
        .attr("fill","#666");

//Draw the spline
svg.append("path")
     .attr("id","mainPath")
     .attr("d", createLine);

//Draw the draggable circle
svg.append("circle").attr("cx",bx).attr("cy",by).attr("r",10)
        .attr("id","draggableCircle");

var oldMouseY = 0;
var boundary = null;
var passedMiddle = 0;
var currentView = 0, nextView = 1;
var lastView = viewPoints.length-1;
var timeDirection = 1; //Direction travelling along time (different than direction of dragging)
var interpValue = 0;
var xSpacing = 80; //Between views

//Create the dragging function
var dragging = d3.behavior.drag() 
        .on("dragstart",function (d){
             passedMiddle = 0;
             boundary = (currentDirection==1)?(by-amplitude):(amplitude+by);
             return d;
        })
        .on("drag", function(d){
            var mouseY = d3.event.y, mouseX = d3.event.x;
            var newY;
            //Figure out the dragging direction (up or down)
            var direction = (mouseY<oldMouseY)?1:-1;
            //Make sure the mouse stays in bounds
            var bounds = checkBounds(boundary,by,mouseY);

             if (bounds == mouseY){
                 findInterpolation(boundary,by,mouseY);
                 translatePath();               
                 console.log("time direction: "+timeDirection+" "+interpValue);
                 newY = mouseY;
                // console.log("in bounds)";
             }else if (bounds == boundary){ //At boundary
                 if (timeDirection ==1){passedMiddle = 1}
                 else {passedMiddle =0;}
                 newY = boundary;
             }else{ //At base
                 //Update the view
                 if (timeDirection ==1){
                     moveForward();
                     passedMiddle = 0;
                 }else{
                     moveBackward();
                     passedMiddle = 1;
                 }
                console.log(currentView+" "+nextView);
                newY=by;
             }
            //console.log(mouseY+" "+boundary+" "+by);
            //console.log(timeDirection);
            //console.log(passedMiddle);
            //Redraw the point along the sine wave to reflect the dragging amount
            d3.select("#draggableCircle").attr("cy",newY);
            oldMouseY = mouseY;
        });

//Set the dragging function of the draggable circle
svg.select("#draggableCircle").call(dragging);

/**Checks if and where the mouse lies between boundary values h1 and h2 */
function checkBounds (h1,h2,mouseY){
    //Resolve the boundaries
    var start,end;
    if (h1>h2){
        end = h1;
        start =h2;
    }else{
        start = h1;
        end = h2;
    }

    //Check if the mouse is between start and end values
    if (mouseY <= start) {
        return start;
    }else if (mouseY >=end) {
        return end;
    }
    return mouseY;
}
/**Finds the approximate distance travelled between views and 
* updates the time direction to show whether the user is moving 
* forward or backward in time*/
function findInterpolation(boundary,by,mouse){
    var travelled;
    var total = Math.abs(boundary - by);
	var currentInterpValue;
    if (passedMiddle ==0 ){ //Needs to be re-mapped to lie between [0,0.5] (towards the peak/trough)
         travelled = Math.abs(mouse - by);
         currentInterpValue = travelled/(total*2);
    }else{ //Needs to be re-mapped to lie between [0.5,1] (passed the peak/trough)
        travelled = Math.abs(mouse - boundary);
        currentInterpValue = (travelled+total)/(total*2);
    }
	//Find the direction travelling over time
	if (currentInterpValue > interpValue){
	    timeDirection = 1;
	}else{
	    timeDirection = -1;
	}
	//Save the new interpValue
	interpValue = currentInterpValue;
}
/**Updates the view variables to move backward along the sine wave */
function moveBackward (){
   if (currentView > 0){
        nextView = currentView;
        currentView--;
        currentDirection = (currentDirection==1)?-1:1;
        boundary = (currentDirection==1)?(by-amplitude):(amplitude+by);
    }
}
/**Updates the view variables to move forward along the sine wave */
function moveForward (){
    if (nextView < lastView){ //Avoid index out of bounds
        currentView = nextView;
        nextView++;
        currentDirection = (currentDirection==1)?-1:1;
        boundary = (currentDirection==1)?(by-amplitude):(amplitude+by);
    }
}
/**Translates the sine wave horizontally to show movement over time */
function translatePath(){
    var translateAmount = xSpacing*interpValue + xSpacing*currentView;

    d3.select("#mainPath").transition().ease("linear")
    .attr("transform", "translate(" + (-translateAmount) + ")"); 
    
    d3.selectAll(".labels").transition().ease("linear")
    .attr("transform", "translate(" + (-translateAmount) + ")");
}
/**Generates a set of points which extend from cx,cy in arbitrary angular directions
 * base: the horizontal axis of the wave
 * length: number of points (draw half a period between points) */
function generatePoints(length){
    var pathPoints = [];
    var viewPoints = [];
    //Calculate the period
    var totalPts = 3*length + (length-3);
    var angle = 0;
    for (var j=0;j<totalPts;j++){
        var theta = angle + (Math.PI/4)*j;
        var y = amplitude*Math.sin(theta)+by;
        var x = (xSpacing/2)*j + bx;
        if (j%4 == 0) viewPoints.push([x,y]);
        pathPoints.push([x,y]);
    }
    return [pathPoints,viewPoints];
}
</script>