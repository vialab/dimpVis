<!DOCTYPE html>
<meta charset="utf-8">
<body>
<style>

path {
  fill: none;
  stroke: #000;
  stroke-width: 2px;
}

</style>
<script src="../JS/d3.js"></script>
<script>

/** This is an example of dragging a point along a sine wave */

var createLine = d3.svg.line()
    .interpolate("monotone"); //Cubic interpolation, need more points to make it look smoother

var bx = 80, by= 40; //Positioning the wave
var radius = 200;
var amplitude = 30;
var xSpacing = 40;
var startDirection = -1; //Starts with a trough
var endDirection = 1; //Ends with a peak
var currentDirection = startDirection;
var boundary = null;
var currentView = 0, nextView = 1;
var passedMiddle = 0;
var savedMouseY = by;
    
var allPoints = generatePoints(10,9); //Generate a set of points for drawing the curve
var points = allPoints[0]; //All points to make the dataset more fine grained (smoother curve)
//var viewPoints = allPoints[1]; //Points indexed to the views
//console.log(viewPoints);
//points.map(function (d){ if (d[1].toFixed(0)!=by) viewPoints.push(d[1])}); //Points indexed to the views

var horizontalLength = points[points.length-1][0] - bx; //how big the sinewave spans horizontally

//Set up the main svg
var svg = d3.select("body").append("svg")
    .datum(points)
    .attr("width", 960)
    .attr("height", 500);

//Draw the individual points (mainly for debugging)
svg.selectAll(".points").data(points).enter()
        .append("circle").attr("r",3)
        .attr("cx", function (d){return d[0]})
        .attr("cy", function (d){return d[1]})
        .attr("class",".points");

//Draw the spline
svg.append("path")
     .attr("id","mainPath")
     .attr("d", createLine);

//Draw the draggable circle
svg.append("circle").attr("cx",bx).attr("cy",by).attr("r",10)
        .attr("fill","red").attr("id","draggableCircle");

//Create the dragging function
var dragging = d3.behavior.drag() 
        .on("dragstart",function (d){
             passedMiddle = 0;
             return d;
        })
        .on("drag", function(){
            var mouseY = d3.event.y, mouseX = d3.event.x;
            var boundary = (currentDirection==1)?(by-amplitude):(amplitude+by);
            var pt1 = points[currentView];
            var pt2 = points[nextView];
            var bounds = checkBounds(boundary,by,mouseY);

            if (bounds == mouseY){
                //Re-set the current direction                 
                currentDirection = (mouseY > savedMouseY)?-1:1;
                
                //Using the delta x as a measure to approximate where the point is drawn will only work for wide sine waves
                var path = d3.select("#mainPath").node();
                var length = path.getTotalLength();
                var amountTravelled =  (mouseX - bx)/horizontalLength;
                var newPoint = path.getPointAtLength(length*amountTravelled);
                d3.select("#draggableCircle").attr("cx",newPoint.x).attr("cy",newPoint.y);
                
                savedMouseY = mouseY;
                
                return;
            }
            else if (bounds == boundary){
                console.log(mouseY+" "+boundary);
                if ((currentDirection ==1 && mouseY>=boundary)||(currentDirection==-1 && mouseY<=boundary)){//Prevent the mouse from going beyond the boundaries
                    if (passedMiddle == 0){
                        passedMiddle = 1;
                    }
                    console.log("at boundary");
                }
            }else{
                if (passedMiddle == 1){
                    passedMiddle = 0;                    
                }
                console.log("at base");
            }
        });

//Set the dragging function of the draggable circle
svg.select("#draggableCircle").call(dragging);

/**Generates a set of points which extend from cx,cy in arbitrary angular directions
 * base: the horizontal axis of the wave
 * length: number of points (draw half a period between points) */
function generatePoints(base,length){
    var pathPoints = [];
    var viewPoints = [];
    //Calculate the period
    var totalPts = 3*length + (length-1);
    var angle = 0;
    for (var j=0;j<totalPts;j++){
        var theta = angle + (Math.PI/4)*j;
        var y = amplitude*Math.sin(theta)+by;
        var x = (xSpacing/2)*j + bx;
        if (j%2 == 0) viewPoints.push([x,y]);
        pathPoints.push([x,y]);
    }
    return [pathPoints,viewPoints];
}

function checkBounds (h1,h2,mouseY){
    //Resolve the boundaries
    var start,end;
    if (h1>h2){
        end = h1;
        start =h2;
    }else{
        start = h1;
        end = h2;
    }

    //Check if the mouse is between start and end values
    if (mouseY <= start) {
        return start;
    }else if (mouseY >=end) {
        return end;
    }
    //Find the amount travelled from current to next view (remember: h1 is current and h2 is next)
    /**var distanceTravelled = Math.abs(mouseY-h1);
    var totalDistance = Math.abs(h2 - h1);
    var distanceRatio = distanceTravelled/totalDistance;
    //Set the previous direction
    if (distanceRatio > this.interpValue){ //Moving forward
        if (this.previousDirection == -1){
            this.previousDirection = 1;
        }
    }else { //Going backward
        if (this.previousDirection == 1){
            this.previousDirection = -1;
        }
    }
    //Save the current interpolation value
    this.interpValue = distanceRatio;*/
    return mouseY;
}

</script>